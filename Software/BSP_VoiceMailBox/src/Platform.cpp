/*
 * In case this Project is ported to another STM controller, a new IOC configuration had to be done.
 * For example the GPIO for the leds and the buttons can be named differently in the CUBEMX.
 * In this case, change the initialisation of the arrays for the leds and buttons. 
 * The new macro names can be found in the main.h file, which is generated by the CUBEMX.
 * 
 * In the case that the BSP of the STM32 uP has changed, change the implementation functions below to stay compatible.
 */

#include "platform.hpp"
#include "HAL_abstraction.hpp"
#include <stdint.h>

#include <cstdarg>   // <-- required for va_list and related macros
#include <cstdio>    // <-- required for vsnprintf
#include <cstring>


namespace VoiceMailBox
{

	/*
		Fill in the GPIO_TypeDef* and pin values, generated from the CUBEMX for the LEDs
	*/
	DIGITAL_PIN Platform::led[] = {
		{ LED0_GPIO_Port, LED0_Pin },
		{ LED1_GPIO_Port, LED1_Pin }
	};

	/*
		Fill in the GPIO_TypeDef* and pin values, generated from the CUBEMX for the buttons
	*/
	DIGITAL_PIN Platform::button[] = {
		{ BTN0_GPIO_Port, BTN0_Pin },
		{ BTN1_GPIO_Port, BTN1_Pin },
		{ BTN2_GPIO_Port, BTN2_Pin },
		{ BTN3_GPIO_Port, BTN3_Pin }
	};


	/*
		Fill in the ADC_TypeDef* and channel values, generated from the CUBEMX for the ADC Potis
	*/
	ANALOG_PIN Platform::adcPotis[] = {
		{ (void*)getADC_POT0() }, // maybe problematic because of static initialization order
		{ (void*)getADC_POT1() }
	};

	/*
		Fill in the UART_HandleTypeDef* value, generated from the CUBEMX for the UART
	*/
	UART Platform::dbgUart(getUART_DEBUG(), 256); // maybe problematic because of static initialisation order
	//UART Platform::wifiUart(getUART_WIFI(), 64); // maybe problematic because of static initialisation order


	// 0x18 is the default address for the TLV320AIC3104
	Codec_TLV320AIC3104 Platform::codec(getI2S_CODEC(), 512,
										getI2C_CODEC(), 0x18,  // maybe problematic because of static initialisation order
										CODEC_NRESET_GPIO_Port, CODEC_NRESET_Pin);

	ATCommandClient Platform::pmodESP(getUART_WIFI(), 256); // maybe problematic because of static initialisation order


#ifdef VMB_DEVELOPMENT_CONFIGURATION
	DIGITAL_PIN Platform::dbgPins[] =
	{
		{ DBG0_GPIO_Port, DBG0_Pin },
		{ DBG1_GPIO_Port, DBG1_Pin },
		{ DBG2_GPIO_Port, DBG2_Pin }
	};
#endif


	void Platform::setup()
	{
		VMB_HAL_InitTickCounter();


		dbgUart.setup();
		pmodESP.setup();
		//wifiUart.setup();

		codec.setup();
	}



	



	



	



	namespace Utility
	{
		constexpr std::size_t print_buffer_size = 256;


		

		void delay(uint32_t ms)
		{
			VMB_HAL_Delay(ms);
		}
		void print(const char* str, va_list args)
		{
			char buffer[print_buffer_size];
			vsnprintf(buffer, sizeof(buffer), str, args);
			Platform::dbgUart.send((uint8_t*)buffer, strlen(buffer));
		}
		void println(const char* str, va_list args)
		{
			char buffer[print_buffer_size];
			uint16_t size = strlen(str);
			if(size > sizeof(buffer) - 3) // Ensure there's space for newline characters
			{
				size = sizeof(buffer) - 3; // Leave space for newline characters
			}
			vsnprintf(buffer, sizeof(buffer), str, args);
			
			buffer[size] = '\r'; // Add newline character
			buffer[size+1] = '\n'; // Add newline character
			buffer[size+2] = 0; // Add newline character
			Platform::dbgUart.send((uint8_t*)buffer, strlen(buffer));
		}

		uint32_t getTickCount()
		{
			return VMB_HAL_GetTickCount();
		}
		void resetTickCount()
		{
			VMB_HAL_ResetTickCounter();
		}
	}


	
}






