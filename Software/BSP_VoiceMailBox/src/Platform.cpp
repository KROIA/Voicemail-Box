/*
 * In case this Project is ported to another STM controller, a new IOC configuration had to be done.
 * For example the GPIO for the leds and the buttons can be named differently in the CUBEMX.
 * In this case, change the initialisation of the arrays for the leds and buttons. 
 * The new macro names can be found in the main.h file, which is generated by the CUBEMX.
 * 
 * In the case that the BSP of the STM32 uP has changed, change the implementation functions below to stay compatible.
 */

#include "platform.hpp"
#include "main.h"
#include <stdint.h>
#include <string>
#include <cstdarg>   // <-- required for va_list and related macros
#include <cstdio>    // <-- required for vsnprintf
#include <cstring>


namespace VoiceMailBox
{

	/*
		Fill in the GPIO_TypeDef* and pin values, generated from the CUBEMX for the LEDs
	*/
	DIGITAL_PIN Platform::led[] = {
		{ LED0_GPIO_Port, LED0_Pin },
		{ LED1_GPIO_Port, LED1_Pin }
	};

	/*
		Fill in the GPIO_TypeDef* and pin values, generated from the CUBEMX for the buttons
	*/
	DIGITAL_PIN Platform::button[] = {
		{ BTN0_GPIO_Port, BTN0_Pin },
		{ BTN1_GPIO_Port, BTN1_Pin },
		{ BTN2_GPIO_Port, BTN2_Pin },
		{ BTN3_GPIO_Port, BTN3_Pin }
	};


	/*
		Fill in the ADC_TypeDef* and channel values, generated from the CUBEMX for the ADC Potis
	*/
	ANALOG_PIN Platform::adcPotis[] = {
		{ (void*)getADC_POT0() }, // maybe problematic because of static initialization order
		{ (void*)getADC_POT1() }
	};

	/*
		Fill in the UART_HandleTypeDef* value, generated from the CUBEMX for the UART
	*/
	UART Platform::dbgUart = { getUART_DEBUG() }; // maybe problematic because of static initialisation order
	UART Platform::wifiUart = { getUART_WIFI() }; // maybe problematic because of static initialisation order


	void Platform::setup()
	{
		dbgUart.startRX_DMA();
		wifiUart.startRX_DMA();
	}



	void DIGITAL_PIN::set(bool on)
	{
		HAL_GPIO_WritePin(static_cast<GPIO_TypeDef*>(gpio), pin, (GPIO_PinState)on);
	}
	void DIGITAL_PIN::toggle()
	{
		HAL_GPIO_TogglePin(static_cast<GPIO_TypeDef*>(gpio), pin);
	}
	bool DIGITAL_PIN::get()
	{
		return HAL_GPIO_ReadPin(static_cast<GPIO_TypeDef*>(gpio), pin) == GPIO_PIN_SET;
	}



	uint32_t ANALOG_PIN::getValue()
	{
		uint32_t value = 0;
		ADC_HandleTypeDef* _adc = static_cast<ADC_HandleTypeDef*>(adc);
		HAL_ADC_Start(_adc);
		if (HAL_ADC_PollForConversion(_adc, 10) == HAL_OK)
		{
			value = HAL_ADC_GetValue(_adc);
		}
		HAL_ADC_Stop(_adc);
		return value;
	}


	UART::UART(void* uartHandle)
		: uart(uartHandle)
	{
		memset(rx_buffer, 0, sizeof(rx_buffer));
		memset(tx_buffer, 0, sizeof(tx_buffer));
		current_RX_Buffer = rx_buffer[0];
		bufferSwitcher = 1;
		//dataReceived = false;
		dataSize = 0;
		//HAL_UART_Receive_IT(static_cast<UART_HandleTypeDef*>(uart), current_RX_Buffer, buffer_size);
		
		//HAL_UART_Receive_DMA(static_cast<UART_HandleTypeDef*>(uart), current_RX_Buffer, buffer_size);
	}
	void UART::startRX_DMA()
	{
		HAL_UARTEx_ReceiveToIdle_DMA(static_cast<UART_HandleTypeDef*>(uart), current_RX_Buffer, buffer_size);
	}

	void UART::send(const char* str)
	{
		send((uint8_t*)str, strlen(str));
	}
	void UART::send(uint8_t* data, uint16_t size)
	{
		if (size > buffer_size)
		{
			size = buffer_size;
		}
		if (data == nullptr)
		{
			return;
		}
		memcpy(tx_buffer, data, size);
		//HAL_UART_Transmit(static_cast<UART_HandleTypeDef*>(uart), tx_buffer, size, 0);
		HAL_UART_Transmit_DMA(static_cast<UART_HandleTypeDef*>(uart), tx_buffer, size);		
	}

	uint16_t UART::hasBytesReceived()
	{
		return dataSize;
	}
	bool UART::receive(uint8_t* data, uint16_t size)
	{
		//receive(data, size, 0);
		if (dataSize == 0)
		{
			return false;
		}
		if (size > dataSize)
		{
			size = dataSize;
		}
		if (data == nullptr)
		{
			return false;
		}
		memcpy(data, current_RX_Buffer, size);
		dataSize = 0;
		return true;
	}
	//void UART::receive(uint8_t* data, uint16_t size, uint32_t timeout)
	//{
	//	HAL_UART_Receive(static_cast<UART_HandleTypeDef*>(uart), data, size, timeout);
	//}
	void UART::onDMAReceivedData(uint16_t size)
	{
		uint8_t* nextBuffer = rx_buffer[bufferSwitcher];
		bufferSwitcher = !bufferSwitcher;
		
		HAL_UARTEx_ReceiveToIdle_DMA(static_cast<UART_HandleTypeDef*>(uart), nextBuffer, buffer_size);
		//HAL_UART_Receive_DMA(static_cast<UART_HandleTypeDef*>(uart), nextBuffer, buffer_size);
		dataSize = size;
		//dataReceived = true;
		current_RX_Buffer = rx_buffer[bufferSwitcher];
	}


	namespace Utility
	{
		constexpr std::size_t print_buffer_size = 256;


		

		void delay(uint32_t ms)
		{
			HAL_Delay(ms);
		}
		void print(const char* str, va_list args)
		{
			char buffer[print_buffer_size];
			vsnprintf(buffer, sizeof(buffer), str, args);
			Platform::dbgUart.send((uint8_t*)buffer, strlen(buffer));
		}
		void println(const char* str, va_list args)
		{
			char buffer[print_buffer_size];
			uint16_t size = strlen(str);
			if(size > sizeof(buffer) - 3) // Ensure there's space for newline characters
			{
				size = sizeof(buffer) - 3; // Leave space for newline characters
			}
			vsnprintf(buffer, sizeof(buffer), str, args);
			
			buffer[size] = '\r'; // Add newline character
			buffer[size+1] = '\n'; // Add newline character
			buffer[size+2] = 0; // Add newline character
			Platform::dbgUart.send((uint8_t*)buffer, strlen(buffer));
		}
	}


	
}


void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef* huart, uint16_t Size) {
	if (huart == static_cast<UART_HandleTypeDef*>(VoiceMailBox::Platform::wifiUart.uart)) {
		VoiceMailBox::Platform::wifiUart.onDMAReceivedData(Size);
	}
	else if (huart == static_cast<UART_HandleTypeDef*>(VoiceMailBox::Platform::dbgUart.uart)) {
		VoiceMailBox::Platform::dbgUart.onDMAReceivedData(Size);
	}
	else {
		// Handle other UARTs if necessary
	}
}
