/*
 * In case this Project is ported to another STM controller, a new IOC configuration had to be done.
 * For example the GPIO for the leds and the buttons can be named differently in the CUBEMX.
 * In this case, change the initialisation of the arrays for the leds and buttons. 
 * The new macro names can be found in the main.h file, which is generated by the CUBEMX.
 * 
 * In the case that the BSP of the STM32 uP has changed, change the implementation functions below to stay compatible.
 */

#include "platform.hpp"
#include "main.h"
#include <stdint.h>

#include <cstdarg>   // <-- required for va_list and related macros
#include <cstdio>    // <-- required for vsnprintf
#include <cstring>


namespace VoiceMailBox
{

	/*
		Fill in the GPIO_TypeDef* and pin values, generated from the CUBEMX for the LEDs
	*/
	DIGITAL_PIN Platform::led[] = {
		{ LED0_GPIO_Port, LED0_Pin },
		{ LED1_GPIO_Port, LED1_Pin }
	};

	/*
		Fill in the GPIO_TypeDef* and pin values, generated from the CUBEMX for the buttons
	*/
	DIGITAL_PIN Platform::button[] = {
		{ BTN0_GPIO_Port, BTN0_Pin },
		{ BTN1_GPIO_Port, BTN1_Pin },
		{ BTN2_GPIO_Port, BTN2_Pin },
		{ BTN3_GPIO_Port, BTN3_Pin }
	};


	/*
		Fill in the ADC_TypeDef* and channel values, generated from the CUBEMX for the ADC Potis
	*/
	ANALOG_PIN Platform::adcPotis[] = {
		{ (void*)getADC_POT0() }, // maybe problematic because of static initialization order
		{ (void*)getADC_POT1() }
	};

	/*
		Fill in the UART_HandleTypeDef* value, generated from the CUBEMX for the UART
	*/
	UART Platform::dbgUart = { getUART_DEBUG() }; // maybe problematic because of static initialisation order
	UART Platform::wifiUart = { getUART_WIFI() }; // maybe problematic because of static initialisation order


	// 0x18 is the default address for the TLV320AIC3104
	Codec_TLV320AIC3104 Platform::codec(getI2S_CODEC(),
										getI2C_CODEC(), 0x18,  // maybe problematic because of static initialisation order
										CODEC_NRESET_GPIO_Port, CODEC_NRESET_Pin);

	void Platform::setup()
	{
		// Setup Tick counter
		// Enable TRC (Trace)
		CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
		// Enable the cycle counter
		DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
		// Optional: Reset the counter to 0
		DWT->CYCCNT = 0;


		dbgUart.setup();
		wifiUart.setup();

		codec.setup();
	}



	



	



	



	namespace Utility
	{
		constexpr std::size_t print_buffer_size = 256;


		

		void delay(uint32_t ms)
		{
			HAL_Delay(ms);
		}
		void print(const char* str, va_list args)
		{
			char buffer[print_buffer_size];
			vsnprintf(buffer, sizeof(buffer), str, args);
			Platform::dbgUart.send((uint8_t*)buffer, strlen(buffer));
		}
		void println(const char* str, va_list args)
		{
			char buffer[print_buffer_size];
			uint16_t size = strlen(str);
			if(size > sizeof(buffer) - 3) // Ensure there's space for newline characters
			{
				size = sizeof(buffer) - 3; // Leave space for newline characters
			}
			vsnprintf(buffer, sizeof(buffer), str, args);
			
			buffer[size] = '\r'; // Add newline character
			buffer[size+1] = '\n'; // Add newline character
			buffer[size+2] = 0; // Add newline character
			Platform::dbgUart.send((uint8_t*)buffer, strlen(buffer));
		}

		uint32_t getTickCount()
		{
			//return HAL_GetTick();
			return DWT->CYCCNT;
		}
		void resetTickCount()
		{
			DWT->CYCCNT = 0;
		}
	}


	
}


#if UART_USE_RX_DMA == 1
void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef* huart, uint16_t Size)
{
	if (huart == static_cast<UART_HandleTypeDef*>(VoiceMailBox::Platform::wifiUart.uart)) {
		VoiceMailBox::Platform::wifiUart.onDMAReceivedData(Size);
	}
	else if (huart == static_cast<UART_HandleTypeDef*>(VoiceMailBox::Platform::dbgUart.uart)) {
		VoiceMailBox::Platform::dbgUart.onDMAReceivedData(Size);
	}
	else {
		// Handle other UARTs if necessary
	}
}
#else
// Called when one byte is received
void HAL_UART_RxCpltCallback(UART_HandleTypeDef* huart)
{
	if (huart == static_cast<UART_HandleTypeDef*>(VoiceMailBox::Platform::wifiUart.uart)) {
		VoiceMailBox::Platform::wifiUart.onITReceivedData();
	}
	else if (huart == static_cast<UART_HandleTypeDef*>(VoiceMailBox::Platform::dbgUart.uart)) {
		VoiceMailBox::Platform::dbgUart.onITReceivedData();
	}
	else {
		// Handle other UARTs if necessary
	}
}
#endif



void HAL_I2SEx_TxRxHalfCpltCallback(I2S_HandleTypeDef* hi2s)
{
	if (VoiceMailBox::Platform::codec.getI2S().i2s == hi2s)
	{
		VoiceMailBox::Platform::codec.onI2S_DMA_TxRx_HalfCpltCallback();
	}
}


void HAL_I2SEx_TxRxCpltCallback(I2S_HandleTypeDef* hi2s)
{
	if (VoiceMailBox::Platform::codec.getI2S().i2s == hi2s)
	{
		VoiceMailBox::Platform::codec.onI2S_DMA_TxRx_CpltCallback();
	}
}
