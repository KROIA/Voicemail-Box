/**
 * @details 
 * In case this Project is ported to another STM controller, a new IOC configuration had to be done.
 * For example the GPIO for the leds and the buttons can be named differently in the CUBEMX.
 * In this case, change the initialisation of the arrays for the leds and buttons. 
 * The new macro names can be found in the main.h file, which is generated by the CUBEMX.
 * 
 * In the case that the BSP of the STM32 uP has changed, change the implementation functions below to stay compatible.
 */

#include "platform.hpp"
#include "HAL_abstraction.hpp"
#include "utilities/Updatable.hpp"
#include "utilities/Logger.hpp"
#include <stdint.h>

#include <cstdarg>   // <-- required for va_list and related macros
#include <cstdio>    // <-- required for vsnprintf
#include <cstring>


namespace VoiceMailBox
{


	// Fill in the GPIO_TypeDef* and pin values, generated from the CUBEMX for the LEDs
	DigitalPin& Platform::getLed(LED index)
	{
		// Creating static instances of the DigitalPin class for each LED
		// The constructor of the DigitalPin class takes the <GPIO_TypeDef*>, <pin number> and <isInverted> as parameters
		// On this board the LEDs are active low, so the isInverted parameter is set to true
		static DigitalPin led[] = 
		{
			{ LED0_GPIO_Port, LED0_Pin, true},
			{ LED1_GPIO_Port, LED1_Pin, true} 
		};

		return led[index];
	}

	
	// Fill in the GPIO_TypeDef* and pin values, generated from the CUBEMX for the buttons
	DigitalPin& Platform::getButton(Button index)
	{
		// Creating static instances of the DigitalPin class for each button
		// The constructor of the DigitalPin class takes the <GPIO_TypeDef*>, <pin number> and <isInverted> as parameters
		// On this board the buttons are active high, so the isInverted parameter is set to false or can be omitted
		static DigitalPin button[] = 
		{
			{ BTN0_GPIO_Port, BTN0_Pin, true},
			{ BTN1_GPIO_Port, BTN1_Pin, true},
			{ BTN2_GPIO_Port, BTN2_Pin, true},
			{ BTN3_GPIO_Port, BTN3_Pin, true}
		};
		return button[index];
	}


	
	// Fill in the ADC_TypeDef* and channel values, generated from the CUBEMX for the ADC Potis
	AnalogPin& Platform::getPotentiometer(Potentiometer index)
	{
		// Creating static instances of the AnalogPin class for each ADC
		// The constructor of the AnalogPin class takes the <ADC_TypeDef*> 
		// Getting the ADC handle from the main.h file, which is generated by the CUBEMX.
		// Getter functions must be declared in the main.h file to return the pointer to the ADC handle created in the main.c file
		static AnalogPin adcPotis[] = 
		{
			{ static_cast<VMB_ADC_Handle*>(getADC_POT0()) }, 
			{ static_cast<VMB_ADC_Handle*>(getADC_POT1()) }  
		};
		return adcPotis[index];
	}

	
	// Fill in the UART_HandleTypeDef* value, generated from the CUBEMX for the UART
	UART& Platform::getDebugUART()
	{
		// Creating static instances of the UART class for the debug UART
		// The constructor of the UART class takes the <UART_HandleTypeDef*> and <buffer size> as parameters
		// The buffer size will not be used if the macro VMB_UART_USE_STATIC_BUFFER_SIZE in the settings.h file is defined
		// Getting the UART handle from the main.h file, which is generated by the CUBEMX.
		// Getter functions must be declared in the main.h file to return the pointer to the UART handle created in the main.c file
		static UART dbgUart(getUART_DEBUG(), 256); // maybe problematic because of static initialisation order
		return dbgUart;
	}


	

	Codec_TLV320AIC3104& Platform::getCodec()
	{
		// Creating static instances of the Codec_TLV320AIC3104 class for the audio codec
		// The constructor of the Codec_TLV320AIC3104 class takes the 
		//    <I2S_HandleTypeDef*>, 
		//    <i2s buffer size>,
		//    <I2C_HandleTypeDef*>,
		//    <I2C address>,
		//    <GPIO_TypeDef*>,
		//    <pin number> as parameters
		// The I2S buffer size will not be used if the macro VMB_I2S_USE_STATIC_BUFFER_SIZE in the settings.h file is defined
		// 0x18 is the default address for the TLV320AIC3104
		static Codec_TLV320AIC3104 codec(getI2S_CODEC(), 512,
				getI2C(), 0x18,  // maybe problematic because of static initialisation order
				CODEC_NRESET_GPIO_Port, CODEC_NRESET_Pin);
		return codec;
	}

	
	ATCommandClient& Platform::getPmodESP()
	{
		// Creating static instances of the ATCommandClient class for the Pmod ESP
		// The constructor of the ATCommandClient class takes the <UART_HandleTypeDef*>, <buffer size> and <DigitalPin&> as parameters
		static ATCommandClient pmodESP(getUART_WIFI(), 256
#ifdef VMB_USE_INTERNAL_LEDS
			, getLed(LED::LED1)
#endif
		);
		return pmodESP;
	}

	I2C& Platform::getI2C()
	{
		// Creating static instances of the I2C class for the I2C bus
		// The constructor of the I2C class takes the <I2C_HandleTypeDef*>
		static I2C i2c(getI2C_Handle());
		return i2c;
	}

#ifdef VMB_DEVELOPMENT_CONFIGURATION
	DigitalPin& Platform::getDebugPin(DBG_PIN index)
	{
		// Creating static instances of the DigitalPin class for each debug pin
		// The constructor of the DigitalPin class takes the <GPIO_TypeDef*>, <pin number> and <isInverted> as parameters
		static DigitalPin dbgPins[] =
		{
			{ DBG0_GPIO_Port, DBG0_Pin },
			{ DBG1_GPIO_Port, DBG1_Pin },
			{ DBG2_GPIO_Port, DBG2_Pin }
		};
		return dbgPins[index];
	}
#endif


	void Platform::setup()
	{
		static bool isSetup = false;
		if (isSetup)
		{
			VMB_LOGGER_PRINTLN("Platform::setup() already done, skipping");
			return;
		}
		isSetup = true; // Set the flag to true to avoid multiple setups
		VMB_LOGGER_PRINTLN("Platform::setup() start");
		bool success = true;
		VMB_HAL_InitTickCounter();
		
		// It is not very important that these functions are called here.
		// But it ensures that the static instances are crated right now and not later
		// when the first access to one of the instances is done.
		getLed(LED::LED0);						// Make sure the static LED instances are created
		getButton(Button::BTN0);				// Make sure the static button instances are created
		getPotentiometer(Potentiometer::POT0);	// Make sure the static ADC instances are created
		
		// Call the setup function of objects that need to be set up explicitly
		success &= File::mount();
		success &= getCodec().setup();
		success &= getDebugUART().setup();
		success &= getPmodESP().setup();
		if (success)
		{
			VMB_LOGGER_PRINTLN("Platform::setup() success");
		}
		else
		{
			VMB_LOGGER_PRINTLN("Platform::setup() failed");
		}
	}	

	void Platform::update()
	{
		Updatable::updateInstances();

#ifdef VMB_ENABLE_SIMULTANEOUS_PLAYBACK_AND_RECORDING
		I2S::clearDataReadyFlagAllInstances();
#endif

		// Update systick counters
		static uint32_t lastTick = 0;
		uint32_t currentTick = VMB_HAL_GetTickCount();
		if (lastTick > currentTick) // Overflown
		{
			VMB_HAL_UpdateTick();
		}
	}
}






