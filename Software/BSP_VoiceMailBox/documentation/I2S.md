# I2C
This class is a simplfied interface to access the i2s peripheral.
All Basic functions used in the project are implemented here.
The implementation does use a DMA in Full-Duplex mode.

- [Features](#features)
- [Setup](#setup)
- [Usage](#usage)
    - [Modify main.h and main.c](#modify-mainh-and-mainc)
    - [Inside the C++ Application](#inside-the-c-application)
- [I2S behind the scenes](#i2s-behind-the-scenes)
    - [Data flow](#data-flow)
    - [Ping-Pong Buffering](#ping-pong-buffering)

---
## Features
- Writing audio samples using a DMA
- Receiving audio samples using a DMA

---
## What is I2S
I2S (Inter-IC Sound) is a serial interface specifically designed for audio data transfer. It is commonly used to transfer digital audio data between microcontrollers, digital-to-analog converters (DACs), and other audio components.
[Click here](#i2s-behind-the-scenes) to learn about how it is implemented in this project.

---
## Setup    
### Inside CubeMX, configure your i2s interface.
  **Mode:** *Full-Duplex Master*
  :white_check_mark: **Master Clock Output**

#### Parameter Settings:
**Transmission Mode:** *Mode Master Transmit*
**Communication Standard:** *I2S Philips*
**Data and Frame Format:** *16Bit Data on 16 Bits Frame*
**Selected Audio Frequency:** *48KHz*
			
#### DMA Settings:
- SPI2_TX:
**Mode:** *Circular*
**Data Width:** *Half Word*


Now start the code generation and open the code editor.

---
## Usage
CubeMX generates a **I2S_HandleTypeDef** instance in the **main.c**
The **I2S** class needs access to that handle. Since the C++ code can't be used directly in the **main.c**, another way of getting to the handle is needed.
Make sure the C++ application is setup, you can find the instructions on how to do so [here](CppFromC.md).

#### Modify main.h and main.c
In the **main.h** create a get function that returns a pointer to the handle we want.
``` C
// main.h

// Function declaration
I2S_HandleTypeDef* getI2S_handle();
```

``` C
// main.c

/* Private variables generated by CubeMX */
I2S_HandleTypeDef hi2s1;

/* USER CODE BEGIN PV */
// Function implementation
I2S_HandleTypeDef* getI2S_handle()
{
    // Return the pointer to the handle
    return &hi2s1;
}
/* USER CODE END PV */
```

#### Inside the C++ Application
``` C++ 
// Application.cpp
#include "BSP_VoiceMailBox.hpp" // includes "peripherals/i2s.hpp"
#include "main.h" // Is needed to access the handle get function
#include <cstring> // Used for memcpy()

// using a namespace globaly is not recommended for production
// but it simplyfies the example here
using namespace VoiceMailBox; 

// Create a I2C object and providing the handle from the main.c
// Use a int16_t[1024] array for data in and out.
I2S i2s(getI2S_handle(), 1024);

void setup()
{ 
    // Start the DMA for RX and TX data transfers
    i2s.startDMA(); 
}

// Called periodically
void loop()
{
    // Check if there was a Ping-Pong swap, triggered by the DMA ISR
    if(i2s.isDataReadyAndClearFlag())
    {
        // Process microphone input and create new audio output
        volatile int16_t* microphoneSamples = i2s.getRxBufPtr();
        volatile int16_t* audioOutSamples = i2s.getTxBufPtr();

        // Size of the current ping or pong buffer
        uint32_t bufferSize = i2s.getBufferSize();

        // Example processing: 
        // Stream the microphone directly back to the output
        memcpy(audioOutSamples, microphoneSamples, bufferSize * sizeof(int16_t));
    }
}
```


## I2S behind the scenes
### Data flow
Since we use the I2S in Full-Duplex mode, we have 2 audio DMA streams which are processed at the same time by the DMA.

>> Bild das den Datenfluss beider DMA Streams zeigt

### Ping-Pong Buffering
Audio data is sampled continuously and it is not possible to store a infinite amount of samples until the recording stops. A simple solution to this problem is a ping-pong buffer.
A ping-pong buffer is a array that is split in 2 equal sized sub array's.

At the start of a DMA transmit, the start of the array is given to the HAL's DMA start call with the half size of the whole array.
While the DMA is processing the first half of the array, the CPU can be used to fill the second half of the DMA buffer.
When the DMA triggers an half complete interrupt, the DMA gets restarted but now with the second half of the array, now using the prepared data in the second half of the array.
While the DMA sends these samples over i2s, the CPU can now fill the first half of the array with new data.

>> Bild das die Zeitliche Abfolge des Ping-Pong buffers und DMA ISR zeigt

Two of these Ping-Pong Buffer array's are implemented in the I2S class. One for microphone data and one for audio output samples.