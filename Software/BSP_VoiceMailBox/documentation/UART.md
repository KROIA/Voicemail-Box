# UART
This class implements the interface for the uart peripheral.
All Basic functions used in the project are implemented here.
The data aquisition is made unsing a interupt-based ring-buffer.
No DMA is used for this implementation.
You can find a ready to run project [here](../../Demos/F469/F469_MultiExample/README.md).

---
## Content
- [Features](#features)
- [Setup](#setup)
- [Usage](#usage)
    - [Modify main.h and main.c](#modify-mainh-and-mainc)
    - [Inside the C++ Application](#inside-the-c-application)

---
## Features
- Sending byte array's over uart
- Receiving byte array's from uart
- Wait and waitAndRead functionality for given strings

---
## Setup    
- Inside CubeMX, configure your uart interface. (NO DMA's)
- Start the code generation and open the code editor.

---
## Usage
CubeMX generates a **UART_HandleTypeDef** instance in the **main.c**
The **UART** class needs access to that handle. Since the C++ code can't be used directly in the **main.c**, another way of getting to the handle is needed.
Make sure the C++ application is setup, you can find the instructions on how to do so [here](CppFromC.md).

#### Modify main.h and main.c
In the **main.h** create a get function that returns a pointer to the handle we need.
``` C
// main.h

// Function declaration
UART_HandleTypeDef* getUART_DEBUG();
```

``` C
// main.c

/* Private variables generated by CubeMX */
UART_HandleTypeDef huart1;

/* USER CODE BEGIN PV */
// Function implementation
UART_HandleTypeDef* getUART_DEBUG()
{
    // Return the pointer to the handle
    return &huart1;
}
/* USER CODE END PV */
```

#### Inside the C++ Application
``` C++ 
// Application.cpp
#include "BSP_VoiceMailBox.hpp" // includes "peripherals/uart.hpp"
#include "main.h" // Is needed to access the handle get function

// using a namespace globaly is not recommended for production
// but it simplyfies the example here
using namespace VoiceMailBox; 

// Create a UART object and providing the handle from the main.c
// Specify the ring-buffer size to 1024 bytes.
VoiceMailBox::UART uart(getUART_DEBUG(), 1024);

void setup()
{
    uart.setup();
}

// Called periodically
void loop()
{
    // Sends a '\0' terminated string over uart.
    // The '\0' will not be sent!
    // The compiler will implicitly add the '\0' at the end of "Hello World\r\n". 
    uart.send("Hello World\r\n");

    // Sends non character bytes using a array and its length in bytes.
    uint8_t data[5] = { 65, 66, 67, '\r', '\n' };
    uart.send(data, sizeof(data));

    // This reads the number of bytes currently received in the buffer and ready to be read
    uint32_t available = uart.hasBytesReceived();

    uint8_t readBuff[1024] = { 0 };
    uart.receive(readBuff, available);
    uart.send(std::string("1: readBuff: \"" + std::string((const char*)readBuff) + "\"\r\n").c_str());
    memset(readBuff, 0, sizeof(readBuff)); // Clear the buffer

    // Waits until the target string was found or the timeout was reached
    if (uart.waitUntil("Target1", 5000))
    {
        // "Target1" was found in the RX buffer
       	uart.send("Target1 was found\r\n");
    }
    else
    {
        // "Target" was never received or the timeout of 5000ms is reached
       	uart.send("Target1 was not found, timeout\r\n");
    }

    // Waits until the target string was found or timeout was reached. 
    // If the target was found, it flushes all bytes 
    // received to the end index of the found target string
    if (uart.waitUntilAndFlush("Target1", 5000))
    {
        // "Target" was found in the RX buffer and flushed
    }
    else
    {
        // "Target" was never received or the timeout of 5000ms is reached
       	uart.send("Target1 was not found, timeout\r\n");
    }

    // Receives all bytes that are comming until the Target string was received or the timeout was reached or the readBuff is full.
    uint32_t received = uart.receiveUntil(readBuff, sizeof(readBuff), (uint8_t*)"Target2", 7, 5000);
    // Example:
    // RX Buffer inside the uart object:
    // |"BlaBlaBlaTest        "|
    //   ^            ^
    //   |            |
    //  Tail         Head
    //
    // readBuff will contain the string: "BlaBlaBla"
    //
    uart.send(std::string("2: readBuff: \"" + std::string((const char*)readBuff) + "\"\r\n").c_str());
}
```